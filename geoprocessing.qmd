# Geoprocessing {#sec-geoprocessing}
We'll explore a number operations in this section that make up what most of us probably think of as typical GIS operations and how to perform them in R - operations such as clipping, subsetting, joining, dissolving, performing map algebra.

Keep in mind as we mentioned earlier that `sf` contains functions that bind to these three primary underlying libraries:

- *GDAL* for reading and writing data
- *GEOS* for geometrical operations
- *PRÃ˜J* for projection conversions and datum transformations

## Goals and Outcomes

* Learn about fundamental spatial operations in R using spatial predicates in `sf` for:
  - subsetting
  - spatial join
  - buffer
  - logical set operations - union / intersection
  - clipping
  - generating centroids and 'casting' to other geometry types
  - other raster from geomputation?
  - chapter 4 in geocomputation?
  
* Explore performing 'map algebra' type operations with raster data in R
* Learn how to do extract and zonal operations in R

## Operations on Geometries
This breakdown of simple features follows for the most part [this section in Spatial Data Science](https://r-spatial.org/book/03-Geometries.html) 

** Simple** and **valid** geometries
- Certain conditions have to be met with simple features:
  + For *linestrings* to be considered *simple* they must not self-intersect:
```{r}
library(sf)
(ls <- st_linestring(rbind(c(0,0), c(1,1), c(2,2), c(0,2), c(1,1), c(2,0))))
```

```{r}
#| message: false
#| echo: false
#| error: false
plot(ls)
```

```{r}
#| message: false
#| echo: false
#| error: false
c(is_simple = st_is_simple(ls))
```

- For *polygons* several other conditions have to be met to be *simple*:

  + polygon rings are closed (the lastpoint equals the first)
  + polygon holes (inner rings) are inside their exterior ring
  + polygon inner rings maximally touch the exterior ring in single points, not over a line
  + a polygon ring does not repeat its own path
  + in a multi-polygon, an external ring maximally touches another exterior ring in single points, not over a line

We can break down operations on geometries for *vector* features in the following way:

-   **predicates**: a logical asserting a certain property is `TRUE`
-   **measures**: a quantity (a numeric value, possibly with measurement unit)
-   **transformations**: newly generated geometries

We can look at these operations by **what** they operate on, whether the are single geometries, pairs, or sets of geometries:

-   **unary** when it's a single geometry
-   **binary** when it's pairs of geometries
-   **n-ary** when it's sets of geometries

**Unary** predicates work to describe a property of a geometry.

A list of unary predicates:

| predicate   | meaning                                         |
|-------------|-------------------------------------------------|
| `is`        | Tests if geometry belongs to a particular class |
| `is_simple` | Tests whether geometry is simple                |
| `is_valid`  | Test whether geometry is valid                  |
| `is_empty`  | Tests if geometry is empty                      |

A list of binary predicates is:

| predicate            | meaning                                                                                                             | inverse of   |
|-----------------|-------------------------------------|-----------------|
| `contains`           | None of the points of A are outside B                                                                               | `within`     |
| `contains_properly`  | A contains B and B has no points in common with the boundary of A                                                   |              |
| `covers`             | No points of B lie in the exterior of A                                                                             | `covered_by` |
| `covered_by`         | Inverse of `covers`                                                                                                 |              |
| `crosses`            | A and B have some but not all interior points in common                                                             |              |
| `disjoint`           | A and B have no points in common                                                                                    | `intersects` |
| `equals`             | A and B are topologically equal: node order or number of nodes may differ; identical to A contains B and A within B |              |
| `equals_exact`       | A and B are geometrically equal, and have identical node order                                                      |              |
| `intersects`         | A and B are not disjoint                                                                                            | `disjoint`   |
| `is_within_distance` | A is closer to B than a given distance                                                                              |              |
| `within`             | None of the points of B are outside A                                                                               | `contains`   |
| `touches`            | A and B have at least one boundary point in common, but no interior points                                          |              |
| `overlaps`           | A and B have some points in common; the dimension of these is identical to that of A and B                          |              |
| `relate`             | Given a mask pattern, return whether A and B adhere to this pattern                                                 |              |

See the [Geometries chapter of Spatial Data Science](https://r-spatial.org/book/03-Geometries.html) for a full treatment that also covers \*\*unary and binary measures\* as well as *unary, binary and n-ary transformers*

```{r, fig.align='center', echo = FALSE, out.width="75%" }
knitr::include_graphics("img/09-sf-model.png")
```

## Measures and Units
Measures (with `sf`) make use of the underlying GEOS library, as well as the R `units` library that provides measure units for R vectors.  Once a coordinate reference system has been defined for features, we often want to ask questions of our data such as:

- How long is a line or a polygon perimeter (unit)
- What is the area of a polygon (unit^2)
- How far apart / close together are objects from each other (unit)

Some examples using county and gage datasets we've seen in previous section (with refresher again on pulling in data from a .csv file with x and y information and making it spatial):
```{r}
#| warning: false
library(readr)
library(sf)
gages <- read_csv(system.file("extdata", "Gages_flowdata.csv", package = "awra2020spatial")) |> 
  dplyr::select(SOURCE_FEA, STATE, LAT_SITE, LON_SITE) |> 
  st_as_sf(coords = c("LON_SITE", "LAT_SITE"), crs = 4269)
st_distance(gages[1,], gages[2,])
```

```{r}
#| echo: true
#| results: hide
library(tigris)
counties <- counties("Oregon", cb = TRUE)
options(scipen=3)
print(paste0('The total area of all counties in Oregon is: ',sum(st_area(counties))))
```

::: {.callout-note appearance="simple" icon="false"}
### Exercise
How did `st_distance` know to return the distance between our 2 gages in meters?  What if we want that distance in feet?  Or kilometers?  Or our total area in Oregon in km2?  There are a couple approaches: 

- you could set a projection that uses the units you want reported
- you could simply look up the conversion factor and apply it manually
- you can make use of the `units` library to explicitly set your units for the data
:::

::: {.callout-note appearance="simple" icon="false" collapse="true"}
### Solution
- Setting the projection for the desired units
```{r}
gages_ft <- st_transform(gages, 2994)
st_distance(gages_ft[1,], gages_ft[2,])
```
:::

## Spatial Subsetting 
Spatial subsetting is analogous to attribute subsetting - with `sf` objects, we can use square bracket (`[]`) notation to take a spatial object and return a new object that contains **only** the features that **relate in space** to another spatial object (i.e. are within, intersect, are within distance of, are spatially disjoint, etc.).

We use the simple syntax of `x[y,]` to perform a spatial subset with the default operation of 'intersects': `x[y,]` is identical to `x[y, , op=st_intersects]`.  We could also provide a different spatial predicate such as `x[y, , op = st_disjoint]`.

Let's run through a couple examples.

First we can demonstrate some very simple spatial subsetting examples using a particular county (polygon) in Oregon and Oregon cities (points).  

```{r}
library(AOI)
library(mapview)
mapviewOptions(fgb=FALSE)
or_cities <- read_sf(system.file("extdata/cities.shp", package = "Rspatialworkshop"))
MultCnt<- aoi_get(state = "OR", county= "Multnomah") |> 
  st_transform(st_crs(or_cities)) # project counties to cities
mapview(MultCnt, alpha.regions=.07, color='black', lwd=2) + mapview(or_cities)
```

Spatially subset cities **within** Multnomah County:
```{r}
mult_cities <- or_cities[MultCnt,]
# or
mult_cities <- or_cities[MultCnt, , op=st_intersects]
mapview(MultCnt, alpha.regions=.07, color='black', lwd=2) + mapview(mult_cities)
```

::: {.callout-note appearance="simple" icon="false"}
### Exercise
Given our explanation above of using different spatial predicates in subsetting operations (e.g. st_disjoint, st_contains,  st_is_within_distance) try:

 - selecting and mapping cities *outside* of Multnomah county
 - selecting and mapping cities *within 50 kilometers* of Multnomah county (or whatever distance you like)
 - using an attribute selection to select a city (or several cities) by name somewhere else in the state.  Using these cities, how would we select and map just the county the *contains* this city / cities? Hint: we'll need to pull in *all* counties of Oregon by modifying `AOI_get()`
:::

::: {.callout-note appearance="simple" icon="false" collapse="true"}
### Solution
Outside Multnomah county:
```{r}
out_mult_cities <- or_cities[MultCnt, , op=st_disjoint]
mapview(MultCnt, alpha.regions=.07, color='black', lwd=2) + mapview(out_mult_cities)
```

Cities within 50km of Multnomah county:
```{r}
close_mult_cities <- or_cities[MultCnt, , op=st_is_within_distance,dist=50000]
mapview(MultCnt, alpha.regions=.07, color='black', lwd=2) + mapview(close_mult_cities)
```

County that contains selected cities:
```{r}
counties <- aoi_get(state='Oregon', county='all') |> 
  st_transform(st_crs(or_cities))
my_cities <- or_cities |> 
  dplyr::filter(CITY %in% c('ASHLAND','BURNS','HOOD RIVER'))
sel_counties <- counties[my_cities, , op=st_contains]
mapview(sel_counties, alpha.regions=.07, color='black', lwd=2) + mapview(my_cities)
```
:::

## Spatial Join 
Often we want to **join** information from one spatial dataset to another based on a spatial relationship rather than attribute relationships - joining attribute data should be a familiar concept to everyone and many of the principles are the same. `st_join` will add new columns from from a source spatial dataset to the target spatial dataset.  

By default `st_join` performs a **left join** (all rows in the target including rows with no match in the source data) - but you can also do an **inner join** by setting `left=FALSE`. 

We can demonstrate the most basic spatial join using our Oregon counties and cities data - here we simply get the county name for every city based on what county each city lands in.
```{r}
cty_cnty <- st_join(or_cities, counties['name'])
dplyr::glimpse(cty_cnty)
```

This is equivalent to:
```{r}
cty_cnty <- st_join(or_cities, counties['name'], .predicate=st_intersects)
dplyr::glimpse(cty_cnty)
```

::: {.callout-note appearance="simple" icon="false"}
### Exercise
Often we want to find what features are within a certain specified distance of other features, or what features are closest to a set of features.  `st_join` can answer these questions by supplying the `st_is_within_distance`
:::

::: {.callout-note appearance="simple" icon="false" collapse="true"}
### Solution
- Setting the projection for the desired units
```{r}
gages_ft <- st_transform(gages, 2994)
st_distance(gages_ft[1,], gages_ft[2,])
```
:::
## Dissolve 
Clarify what dissolve is and it's not using st_dissolve, it's just using tidyverse operations
## Fixing topology errors
- show typical fixes for topology errors

:::{.callout-note}
You may encounter errors like this when running geoprocessing operations like `st_join` in R:
```
Error in wk_handle.wk_wkb(wkb, s2_geography_writer(oriented
= oriented,  :  Loop 0 is not valid: Edge 772 crosses edge 774
```

Running `st_make_valid` might not fix.  

You may need to turn off spherical geometry - `sf_use_s2(TRUE)`, run `st_make_valid`, and then turn spherical geometry back on - `sf_use_s2(FALSE)`
See background on S2 [here](https://r-spatial.org/r/2020/06/17/s2.html) and discussion of S2 related issues [here](https://github.com/r-spatial/sf/issues/1771)
:::

## Extract and Zonal Statistics 




### Raster operations

#### Cropping
We can crop our elevation raster to just the bounding box of Crater Lake - using mask, we can clip it to the actual polygon boundary

Let's see what elevation and Crater Lake boundary look like prior to cropping and masking
```{r crop, message=FALSE, warning=FALSE, error=FALSE, eval=FALSE}
plot(elevation_tm)
plot(CraterLake_tm, add=TRUE, col=NA, border='blue')
```

Here we use `crop` to crop the elevation raster to the bounding box of our Crater Lake polygon feature
```{r crop2, message=FALSE, warning=FALSE, error=FALSE, eval=FALSE}
elev_crop = crop(elevation_tm, vect(CraterLake_tm))
plot(elev_crop)
plot(CraterLake_tm, add=TRUE, col=NA, border='blue')
```

And finally we can use `mask` to mask the raster to just inside the polygon outline of Crater Lake National Park.  

**Note** - if you have a large raster, it makes a HUGE difference to use crop first, then mask - mask is a much more computationally intensive operation so it will pay off to crop first then mask. An interesting twitter thread regarding this just the other day:

```{r, echo=FALSE, out.width="150%"}
knitr::include_graphics("img/tweet1.png")
```

```{r, echo=FALSE, out.width="150%"}
knitr::include_graphics("img/tweet2.png")
```


```{r mask, message=FALSE, warning=FALSE, error=FALSE, eval=FALSE}
elev_mask = mask(elevation_tm, vect(CraterLake_tm))
plot(elev_mask)
plot(CraterLake_tm, add=TRUE, col=NA, border='blue')
```

### Map Algebra
We can divide map algebra into a couple of categories:

1. Local - per-cell operations
    a. raster calculator
    b. replacing values
    c. reclassifying
    d. calculating indices
2. Focal (neighborhood operations) - summarizing output cell value as the result of a window (such as a3 x 3 input cell block)
Zonal operations - summarizing raster values for some zones (either another raster or a vector feature)
Global - summarizing values over entire raster(s)

#### Local Operations
Say we want to convert our elevation raster from meters to feet:
```{r local, message=FALSE, warning=FALSE, error=FALSE, eval=FALSE}
elev_feet = elevation_tm * 3.28084
elev_feet
```

Our max value is 8890, which makes sense - the high point in Crater Lake National Park is Mount Scott at 8,929'.

What if we want to make elevation bins, or classify some elevations as NA with our elevation raster?
```{r local2, message=FALSE, warning=FALSE, error=FALSE, eval=FALSE}
reclass <- matrix(c(0, 500, 1, 500, 1000, 2, 1000, 1500, 3, 1500 , 2000, 4, 2000, 2700, 5), ncol = 3, byrow = TRUE)
reclass
elev_recl = classify(elevation_tm, rcl = reclass)
plot(elevation_tm)
plot(elev_recl)
```

```{r local3, message=FALSE, warning=FALSE, error=FALSE, eval=FALSE}
elev_new = elevation_tm
elev_new[elev_new > 2000] = NA
plot(elev_new)
```

#### Focal Operations
A simple focal window operation
```{r focal, message=FALSE, warning=FALSE, error=FALSE, eval=FALSE}
elev_focal_mean = focal(elevation_tm, 
                   w = matrix(1, nrow = 25, ncol = 25), 
                   fun = mean)
plot(elev_focal_mean)
```

#### Global Operations
```{r global, message=FALSE, warning=FALSE, error=FALSE, eval=FALSE}
terra::global(elev_mask, fun="mean", na.rm=TRUE)
terra::global(elev_mask, fun="sum", na.rm=TRUE)
```

#### Zonal Operations
Here us demonstrate using the zonal function in terra to summarize a value raster of elevation, using an srtm.tif from `spDataLarge`, by the zones of NLCD classes using nlcd.tif raster also in the `spDataLarge` package.
```{r zonal, message=FALSE, warning=FALSE, error=FALSE, eval=FALSE}
srtm_path = system.file("raster/srtm.tif", package = "spDataLarge")
srtm_path
srtm = rast(srtm_path)
srtm

nlcd = rast(system.file("raster/nlcd2011.tif", package = "spDataLarge"))
srtm_utm = project(srtm, nlcd, method = "bilinear")
srtm_zonal = zonal(srtm_utm, nlcd, na.rm = TRUE, fun = "mean")
srtm_zonal
```


